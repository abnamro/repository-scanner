/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/resc/v1/health': {
    /**
     * Health check
     * @description Retrieve the health status of RESC APIs
     */
    get: operations['health_check_resc_v1_health_get'];
  };
  '/resc/v1/supported-vcs-providers': {
    /**
     * Get supported vcs-providers
     * @description Retrieve the supported vcs-providers, example: Bitbucket, AzureDevOps, Github etc
     */
    get: operations['get_supported_vcs_providers_resc_v1_supported_vcs_providers_get'];
  };
  '/resc/v1/auth-check': {
    /**
     * Authorization check
     * @description The output returns 200 OK if auth check is successful else returns 403 Forbidden
     */
    get: operations['auth_check_resc_v1_auth_check_get'];
  };
  '/resc/v1/detected-rules': {
    /**
     * Get unique rules from findings
     * @description Retrieve all uniquely detected rules across all findings in the database
     *
     * - **db_connection**: Session of the database connection
     * - **finding_statuses**: Optional, filter on supported finding statuses
     * - **vcs_providers**: Optional, filter on supported vcs provider types
     * - **project_name**: Optional, filter on project name. It is used as a full string match filter
     * - **repository_name**: Optional, filter on repository name. It is used as a string contains filter
     * - **start_date_time**: Optional, filter on start date
     * - **end_date_time**: Optional, filter on end date
     * - **rule_pack_version**: Optional, filter on rule pack version
     * - **return**: List[str] The output will contain a list of strings of unique rules in the findings table
     */
    get: operations['get_distinct_rules_from_findings_resc_v1_detected_rules_get'];
  };
  '/resc/v1/rules/finding-status-count': {
    /**
     * Get detected rules with counts per status
     * @description Retrieve all detected rules with finding counts per supported status
     *
     * - **rule_pack_version**: Optional, filter on rule pack version
     * - **rule_tag**: Optional, filter on rule tag
     * - **db_connection**: Session of the database connection
     * - **return**: List[str] The output will contain a list of strings of unique rules with counts per status
     */
    get: operations['get_rules_finding_status_count_resc_v1_rules_finding_status_count_get'];
  };
  '/resc/v1/rule-packs/versions': {
    /**
     * Get rule packs
     * @description Retrieve rule packs
     *
     * - **db_connection**: Session of the database connection
     * - **version**: Optional, filter on rule pack version
     * - **active**: Optional, filter on active rule pack
     * - **skip**: Integer amount of records to skip, to support pagination
     * - **limit**: Integer amount of records to return, to support pagination
     * - **return**: [RulePackRead]
     *     The output will contain a PaginationModel containing the list of RulePackRead type objects,
     *     or an empty list if no rule pack was found
     */
    get: operations['get_rule_packs_resc_v1_rule_packs_versions_get'];
  };
  '/resc/v1/rule-packs': {
    /**
     * Download rule pack in TOML format
     * @description Download rule pack in TOML format
     *
     * - **db_connection**: Session of the database connection
     * - **version**: Optional, filter on rule pack version
     * - **return**: [FileResponse] The output returns rule pack file downloaded in TOML format
     */
    get: operations['download_rule_pack_toml_file_resc_v1_rule_packs_get'];
    /**
     * Upload rule pack in TOML format
     * @description Upload TOML rule pack to database
     *
     * - **db_connection**: Session of the database connection
     * - **version**: Version of the rule pack to be uploaded
     * - **rule_file**: TOML rule pack file to be uploaded
     * - **return**: dict The output returns uploaded rule pack name in dictionary format
     */
    post: operations['upload_rule_pack_toml_file_resc_v1_rule_packs_post'];
  };
  '/resc/v1/rule-packs/tags': {
    /**
     * Get rule packs' tags
     * @description Retrieve rule pack related tags
     *
     * :param db_connection: Session of the database connection
     * :param versions: Optional, filter on rule pack version, if not provided filter on active.
     * :return: List[str]
     *     The output will contain a list of tags related to one or more rule-packs.
     */
    get: operations['get_rule_packs_tags_resc_v1_rule_packs_tags_get'];
  };
  '/resc/v1/findings': {
    /**
     * Get findings
     * @description Retrieve all findings objects paginated
     *
     * - **db_connection**: Session of the database connection
     * - **skip**: Integer amount of records to skip to support pagination
     * - **limit**: Integer amount of records to return, to support pagination
     * - **return**: [FindingRead]
     *     The output will contain a PaginationModel containing the list of FindingRead type objects,
     *     or an empty list if no finding was found
     */
    get: operations['get_all_findings_resc_v1_findings_get'];
    /**
     * Create a finding
     * @description Create new findings
     *
     * - **db_connection**: Session of the database connection
     * - **file_path**: file path
     * - **line_number**: Line number
     * - **commit_id**: commit hash
     * - **commit_message**: Commit message
     * - **commit_timestamp**: Commit timestamp
     * - **author**: Author name
     * - **email**: Email of the author
     * - **event_sent_on**: event sent timestamp
     * - **rule_name**: rule name
     * - **repository_id**: repository id of the finding
     * - **return**: int
     *       The output will contain the number of successful created findings
     */
    post: operations['create_findings_resc_v1_findings_post'];
  };
  '/resc/v1/findings/{finding_id}': {
    /**
     * Fetch a finding by ID
     * @description Read a finding by ID
     *
     * - **db_connection**: Session of the database connection
     * - **finding_id**: ID of the finding for which details need to be fetched
     */
    get: operations['read_finding_resc_v1_findings__finding_id__get'];
    /**
     * Delete a finding
     * @description Delete a finding object
     *
     * - **db_connection**: Session of the database connection
     * - **finding_id**: ID of the finding to delete
     * - **return**: The output will contain a success or error message based on the success of the deletion
     */
    delete: operations['delete_finding_resc_v1_findings__finding_id__delete'];
    /**
     * Partially update a finding by ID
     * @description Partially update a finding by ID
     *
     * - **db_connection**: Session of the database connection
     * - **finding_id**: ID of the finding for which details need to be updated
     * - **event_sent_on**: Event sent timestamp
     */
    patch: operations['patch_finding_resc_v1_findings__finding_id__patch'];
  };
  '/resc/v1/findings/total-count-by-rule/{rule_name}': {
    /**
     * Get total findings count by rule
     * @description Retrieve total findings count for a given rule
     *
     * - **db_connection**: Session of the database connection
     * - **rule_name**: name of the rule
     */
    get: operations['get_total_findings_count_by_rule_resc_v1_findings_total_count_by_rule__rule_name__get'];
  };
  '/resc/v1/findings/by-rule/{rule_name}': {
    /**
     * Get findings by rule
     * @description Retrieve all findings objects paginated by rule
     *
     * - **db_connection**: Session of the database connection
     * - **rule_name**: Name of the rule to filter the findings by
     * - **skip**: Integer amount of records to skip to support pagination
     * - **limit**: Integer amount of records to return, to support pagination
     * - **return**: [FindingRead]
     *     The output will contain a PaginationModel containing the list of FindingRead type objects,
     *     or an empty list if no finding was found for the given rule
     */
    get: operations['get_findings_by_rule_resc_v1_findings_by_rule__rule_name__get'];
  };
  '/resc/v1/findings/audit/': {
    /**
     * audit single/multiple findings
     * @description Audit single/multiple findings, updating the status and comment
     *
     * - **db_connection**: Session of the database connection
     * - **finding_ids**: List of finding IDs for which audit to be performed
     * - **status**: Status of the finding, Valid values are NOT_ANALYZED, UNDER_REVIEW,
     *               CLARIFICATION_REQUIRED, FALSE_POSITIVE, TRUE_POSITIVE
     * - **comment**: Comment
     * - **return**: int
     *     The output will contain count of successful saved audits
     */
    post: operations['audit_findings_resc_v1_findings_audit__post'];
  };
  '/resc/v1/findings/{finding_id}/audit': {
    /**
     * Get audit(s) for finding
     * @description Retrieve all audit objects paginated for a finding
     *
     * - **db_connection**: Session of the database connection
     * - **finding_id**: id of the finding to get the audit for
     * - **skip**: Integer amount of records to skip to support pagination
     * - **limit**: Integer amount of records to return, to support pagination
     * - **return**: [AuditRead]
     *     The output will contain a PaginationModel containing the list of AuditRead type objects,
     *     or an empty list if no audit info was found
     */
    get: operations['get_finding_audits_resc_v1_findings__finding_id__audit_get'];
  };
  '/resc/v1/findings/supported-statuses/': {
    /**
     * Get all supported statuses for findings
     * @description Retrieve all supported statuses for findings
     *
     * - **return**: List[str]
     *     The output will contain a list of strings of unique statuses supported
     */
    get: operations['get_supported_statuses_resc_v1_findings_supported_statuses__get'];
  };
  '/resc/v1/findings/count-by-time/{time_type}': {
    /**
     * Get all the findings by time period
     * @description Retrieve all findings count by time period objects paginated
     *
     * - **db_connection**: Session of the database connection
     * - **time_type**: required, filter on time type. Available values: month, week, day
     * - **skip**: Integer amount of records to skip to support pagination
     * - **limit**: Integer amount of records to return, to support pagination
     * - **start_date_time**: Optional, filter on start date
     * - **end_date_time**: Optional, filter on end date
     * - **return**: PaginationModel[DateCountModel]
     *     The output will contain a PaginationModel containing the list of DateCountModel type objects,
     *     or an empty list if no data was found
     */
    get: operations['get_count_by_time_resc_v1_findings_count_by_time__time_type__get'];
  };
  '/resc/v1/detailed-findings': {
    /**
     * Get all detailed findings
     * @description Retrieve all findings objects paginated
     * - **query_string**
     *
     *     A query string with the following format:
     *         param1=value1&param2=value2&param3=value3
     *
     *     Where the possible parameters are:
     *
     *         - vcs_providers [enum] of type VCSProviders, possible values are: BITBUCKET, AZURE_DEVOPS.
     *             Will default to all if non-specified.
     *
     *         - finding_statuses [enum of type FindingStatus], possible values are:NOT_ANALYZED,FALSE_POSITIVE,
     *           TRUE_POSITIVE. Will default to all if non-specified.
     *
     *         - rule_pack_versions of type [String]
     *
     *         - rule_names of type [String]
     *
     *         - rule_tags of type [String] findings in the result will have at least one of the specified tags
     *           for the rules
     *
     *         - project_name of type String
     *
     *         - repository_names of type [String]
     *
     *         - scan_ids of type list Integer
     *
     *         - start_date_time of type datetime with the following format: 1970-01-31T00:00:00
     *
     *         - end_date_time of type datetime with the following format: 1970-01-31T00:00:00
     *
     * - **db_connection**
     *
     *     Session of the database connection
     *
     * - **skip**
     *
     *     Integer amount of records to skip to support pagination
     *
     * - **limit**
     *
     *     Integer amount of records to return, to support pagination
     *
     * - **return** [FindingRead]
     *
     *     The output will contain a PaginationModel containing the list of DetailedFinding type objects,
     *     or an empty list if no finding was found
     */
    get: operations['get_all_detailed_findings_resc_v1_detailed_findings_get'];
  };
  '/resc/v1/detailed-findings/{finding_id}': {
    /**
     * Fetch detailed finding by ID
     * @description Retrieve detailed finding by its ID
     *
     * - **db_connection**: Session of the database connection
     * - **finding_id**: ID of the finding for which details need to be fetched
     * - **return**: [DetailedFindingRead]
     *     The output will contain the details of a finding
     */
    get: operations['read_finding_resc_v1_detailed_findings__finding_id__get'];
  };
  '/resc/v1/repositories': {
    /**
     * Get repositories
     * @description Retrieve all repository objects paginated
     *
     * - **db_connection**: Session of the database connection
     * - **skip**: Integer amount of records to skip to support pagination
     * - **limit**: Integer amount of records to return, to support pagination
     * - **vcsproviders**: Optional, filter on supported vcs provider types
     * - **projectfilter**: Optional, filter on project name. It is used as a string contains filter
     * - **repositoryfilter**: Optional, filter on repository name. It is used as a string contains filter
     * - **return**: [RepositoryRead]
     *     The output will contain a PaginationModel containing the list of RepositoryRead type objects,
     *     or an empty list if no repository
     */
    get: operations['get_all_repositories_resc_v1_repositories_get'];
    /**
     * Create a repository
     * @description Create a repository with all the information
     *
     * - **db_connection**: Session of the database connection
     * - **project_key**: each repository must have a project name or key
     * - **repository_id**: repository id
     * - **repository_name**: repository name
     * - **repository_url**: repository url
     * - **vcs_instance**: vcs instance id
     */
    post: operations['create_repository_resc_v1_repositories_post'];
  };
  '/resc/v1/repositories/{repository_id}': {
    /**
     * Fetch a repository by ID
     * @description Read a repository by ID
     *
     * - **db_connection**: Session of the database connection
     * - **repository_id**: ID of the repository for which details need to be fetched
     */
    get: operations['read_repository_resc_v1_repositories__repository_id__get'];
    /**
     * Update an existing repository
     * @description Update an existing repository
     *
     * - **db_connection**: Session of the database connection
     * - **repository_id**: ID of the repository
     * - **project_key**: project name that needs to be updated
     * - **repository_id**: repository id that needs to be updated
     * - **repository_name**: repository name that needs to be updated
     * - **repository_url**: repository url that needs to be updated
     * - **vcs_instance**: vcs instance id that needs to be updated
     */
    put: operations['update_repository_resc_v1_repositories__repository_id__put'];
    /**
     * Delete a repository
     * @description Delete a repository
     *
     * - **db_connection**: Session of the database connection
     * - **repository_id**: ID of the repository to delete
     * - **return**: The output will contain a success or error message based on the success of the deletion
     */
    delete: operations['delete_repository_resc_v1_repositories__repository_id__delete'];
  };
  '/resc/v1/repositories/distinct-projects/': {
    /**
     * Get all unique project names
     * @description Retrieve all unique project names
     *
     * - **db_connection**: Session of the database connection
     * - **vcsproviders**: Optional, filter on supported vcs provider types
     * - **repositoryfilter**: Optional, filter on repository name. It is used as a string contains filter
     * - **onlyifhasfindings**: Optional, filter all projects those have findings
     * - **return**: List[str]
     *     The output will contain a list of unique projects
     */
    get: operations['get_distinct_projects_resc_v1_repositories_distinct_projects__get'];
  };
  '/resc/v1/repositories/distinct-repositories/': {
    /**
     * Get all unique repository names
     * @description Retrieve all unique repository names
     *
     * - **db_connection**: Session of the database connection
     * - **vcsproviders**: Optional, filter of supported vcs provider types
     * - **projectname**: Optional, filter on project name. It is used as a full string match filter
     * - **onlyifhasfindings**: Optional, filter all repositories that have findings
     * - **return**: List[str]
     *     The output will contain a list of unique repositories
     */
    get: operations['get_distinct_repositories_resc_v1_repositories_distinct_repositories__get'];
  };
  '/resc/v1/repositories/{repository_id}/findings-metadata': {
    /**
     * Get findings metadata for a repository
     * @description Retrieve findings metadata for a repository
     *
     * - **db_connection**: Session of the database connection
     * - **repository_id**: ID of the repository object for which findings metadata to be retrieved
     * - **return**: RepositoryRead, findings count per status
     *     The output will contain a RepositoryRead type object along with findings count per status,
     *     or empty if no scan was found
     */
    get: operations['get_findings_metadata_for_repository_resc_v1_repositories__repository_id__findings_metadata_get'];
  };
  '/resc/v1/repositories/findings-metadata/': {
    /**
     * Get all repositories with findings metadata
     * @description Retrieve all repository objects paginated
     *
     * - **db_connection**: Session of the database connection
     * - **skip**: Integer amount of records to skip to support pagination
     * - **limit**: Integer amount of records to return, to support pagination
     * - **vcsproviders**: Optional, filter on supported vcs provider types
     * - **projectfilter**: Optional, filter on project name. It is used as a string contains filter
     * - **repositoryfilter**: Optional, filter on repository name. It is used as a string contains filter
     * - **onlyifhasfindings**: Optional, filter all repositories those have findings
     * - **return**: [RepositoryEnrichedRead]
     *     The output will contain a PaginationModel containing the list of RepositoryEnrichedRead type objects,
     *     or an empty list if no repository
     */
    get: operations['get_all_repositories_with_findings_metadata_resc_v1_repositories_findings_metadata__get'];
  };
  '/resc/v1/repositories/{repository_id}/last-scan': {
    /**
     * Get latest scan for repository
     * @description Retrieve the latest scan object related to a repository
     *
     * - **db_connection**: Session of the database connection
     * - **repository_id**: ID of the parent repository object for which scan objects to be retrieved
     * - **return**: ScanRead
     *     The output will contain a ScanRead type object,
     *     or empty if no scan was found
     */
    get: operations['get_last_scan_for_repository_resc_v1_repositories__repository_id__last_scan_get'];
  };
  '/resc/v1/repositories/{repository_id}/scans': {
    /**
     * Get scans for repository
     * @description Retrieve all scan objects related to a repository paginated
     *
     * - **db_connection**: Session of the database connection
     * - **repository_id**: ID of the parent repository object for which scan objects to be retrieved
     * - **skip**: Integer amount of records to skip to support pagination
     * - **limit**: Integer amount of records to return, to support pagination
     * - **return**: [ScanRead]
     *     The output will contain a PaginationModel containing the list of ScanRead type objects,
     *     or an empty list if no scan was found
     */
    get: operations['get_scans_for_repository_resc_v1_repositories__repository_id__scans_get'];
  };
  '/resc/v1/scans': {
    /**
     * Get scans
     * @description Retrieve all scan objects paginated
     *
     * - **db_connection**: Session of the database connection
     * - **skip**: Integer amount of records to skip to support pagination
     * - **limit**: Integer amount of records to return, to support pagination
     * - **return**: [ScanRead]
     *     The output will contain a PaginationModel containing the list of ScanRead type objects,
     *     or an empty list if no scan was found
     */
    get: operations['get_all_scans_resc_v1_scans_get'];
    /**
     * Create a scan
     * @description Create a scan with all the information
     *
     * - **db_connection**: Session of the database connection
     * - **scan_type**: scan type, supported values are BASE or INCREMENTAL
     * - **last_scanned_commit**: last scanned commit hash
     * - **timestamp**: creation timestamp
     * - **increment_number**: scan increment number
     * - **rule_pack**: rule pack version
     * - **repository_id**: repository id
     */
    post: operations['create_scan_resc_v1_scans_post'];
  };
  '/resc/v1/scans/{scan_id}': {
    /**
     * Fetch a scan by ID
     * @description Read a scan by ID
     *
     * - **db_connection**: Session of the database connection
     * - **scan_id**: ID of the scan for which details need to be fetched
     */
    get: operations['read_scan_resc_v1_scans__scan_id__get'];
    /**
     * Update an existing scan
     * @description Update an existing scan
     *
     * - **db_connection**: Session of the database connection
     * - **scan_type**: scan type, supported values are BASE or INCREMENTAL
     * - **last_scanned_commit**: last scanned commit
     * - **timestamp**: scan timestamp
     * - **increment_number**: scan increment number
     * - **rule_pack**: rule pack version
     * - **repository_id**: repository id
     */
    put: operations['update_scan_resc_v1_scans__scan_id__put'];
    /**
     * Delete a scan
     * @description Delete a scan object
     *
     * - **db_connection**: Session of the database connection
     * - **scan_id**: ID of the scan to delete
     * - **return**: The output will contain a success or error message based on the success of the deletion
     */
    delete: operations['delete_scan_resc_v1_scans__scan_id__delete'];
  };
  '/resc/v1/scans/{scan_id}/findings': {
    /**
     * Get scan findings associated with a scan ID
     * @description Retrieve all finding objects paginated related to a scan_id
     *
     * - **db_connection**: Session of the database connection
     * - **scan_id**: Id of the scan for which to retrieve the findings
     * - **skip**: Integer amount of records to skip to support pagination
     * - **limit**: Integer amount of records to return, to support pagination
     * - **rules**: optional, filter on rule name. It is used as a string contains filter
     * - **statuses**:  optional, filter on status of findings
     * - **return**: [FindingRead]
     *     The output will contain a PaginationModel containing the list of FindingRead type objects,
     *     or an empty list if no scan was found
     */
    get: operations['get_scan_findings_resc_v1_scans__scan_id__findings_get'];
    /**
     * Create scan findings
     * @description Creates findings and their associated scan_findings for a given scan
     *
     * - **db_connection**: Session of the database connection
     * - **scan_id**:  Id of the scan for which findings need to be inserted
     * - **file_path**: file path
     * - **line_number**: Line number
     * - **column_start**: Column start
     * - **column_end**: Column end
     * - **commit_id**: commit hash
     * - **commit_message**: Commit message
     * - **commit_timestamp**: Commit timestamp
     * - **author**: Author name
     * - **email**: Email of the author
     * - **status**: Status of the finding, Valid values are NOT_ANALYZED, UNDER_REVIEW,
     *               CLARIFICATION_REQUIRED, FALSE_POSITIVE, TRUE_POSITIVE
     * - **comment**: Comment
     * - **event_sent_on**: event sent timestamp
     * - **rule_name**: rule name
     * - **repository_id**: repository id of the finding
     * - **return**: [FindingRead]
     *     The output will contain a PaginationModel containing the list of FindingRead type objects,
     *     or an empty list if no scan was found
     */
    post: operations['create_scan_findings_resc_v1_scans__scan_id__findings_post'];
  };
  '/resc/v1/scans/findings/': {
    /**
     * Get scan findings
     * @description Retrieve all finding objects paginated related to a scan_id
     *
     * - **db_connection**: Session of the database connection
     * - **scan_ids**: Optional, List of scan IDs for which findings to be retrieved
     * - **skip**: Integer amount of records to skip to support pagination
     * - **limit**: Integer amount of records to return, to support pagination
     * - **rule**: optional, filter on rule name. It is used as a string contains filter
     * - **statuses**:  optional, filter on status of findings
     * - **return**: [FindingRead]
     *     The output will contain a PaginationModel containing the list of FindingRead type objects,
     *     or an empty list if no scan was found
     */
    get: operations['get_scans_findings_resc_v1_scans_findings__get'];
  };
  '/resc/v1/scans/detected-rules/': {
    /**
     * Get unique rules from scans
     * @description Retrieve all uniquely detected rules for given scans
     *
     * - **db_connection**: Session of the database connection
     * - **scan_ids**: scan ids for which to retrieve the unique rules
     * - **return**: List[str]
     *     The output will contain a list of strings of unique rules for given scan ids
     */
    get: operations['get_distinct_rules_from_scans_resc_v1_scans_detected_rules__get'];
  };
  '/resc/v1/vcs-instances': {
    /**
     * Get all VCS instances
     * @description Retrieve all VCS instance objects paginated
     *
     * - **db_connection**: Session of the database connection
     * - **skip**: Integer amount of records to skip to support pagination
     * - **limit**: Integer amount of records to return, to support pagination
     * - **vcs_provider_type**: Optional filter on the VCS provider type
     * - **vcs_instance_name**: Optional filter on VCS instance name
     * - **return**: [VCSInstanceRead]
     *     The output will contain a PaginationModel containing the list of VCSInstanceRead type objects,
     *     or an empty list if no VCS instance was found
     */
    get: operations['get_all_vcs_instances_resc_v1_vcs_instances_get'];
    /**
     * Create a VCS instance
     * @description Create new VCS instance object
     *
     * - **db_connection**: Session of the database connection
     * - **vcs_instance**: VCSInstanceCreate type object of the VCS Instance to create
     * - **return**: VCSInstanceRead
     *     The output will contain a VCSInstanceRead type object if the creation was successful
     */
    post: operations['create_vcs_instance_resc_v1_vcs_instances_post'];
  };
  '/resc/v1/vcs-instances/{vcs_instance_id}': {
    /**
     * Fetch a VCS instance by ID
     * @description Retrieve a VCS instance object based on the provided id
     *
     * - **db_connection**: Session of the database connection
     * - **vcs_instance_id**: ID of the VCS instance for which details need to be fetched
     * - **return**: VCSInstanceRead
     *     The output will contain a VCSInstanceRead type object from the requested ID
     */
    get: operations['read_vcs_instance_resc_v1_vcs_instances__vcs_instance_id__get'];
    /**
     * Update an existing VCS instance
     * @description Update a VCS instance
     *
     * - **db_connection**: Session of the database connection
     * - **vcs_instance_id**: ID of the VCS instance to update
     * - **provider_type**: VCS instance name that needs to be updated
     * - **hostname**: Host name of the VCS instance that needs to be updated
     * - **port**: Port number of the VCS instance that needs to be updated
     * - **scheme**: Scheme of the VCS instance that needs to be updated. Allowed values http or https
     * - **exceptions**: List of projects which needs to be updated to exception list, default empty list
     * - **scope**: List of projects which needs to be updated to scope
     * - **organization**: Name of organization to be updated, default is empty
     * - **return**: VCSInstanceRead
     *     The output will contain a VCSInstanceRead type object with the new properties
     */
    put: operations['update_vcs_instance_resc_v1_vcs_instances__vcs_instance_id__put'];
    /**
     * Delete a VCS instance
     * @description Delete a VCS instance by ID
     *
     * - **db_connection**: Session of the database connection
     * - **vcs_instance_id**: ID of the VCS instance to delete
     * - **return**: The output will contain a success or error message based on the success of the deletion
     */
    delete: operations['delete_vcs_instance_resc_v1_vcs_instances__vcs_instance_id__delete'];
  };
  '/resc/v1/metrics/audited-count-over-time': {
    /**
     * Get count of audit status over time for given weeks per vcs provider
     * @description Retrieve count of audited findings over time for given weeks per vcs provider
     * - **db_connection**: Session of the database connection
     * - **weeks**: Nr of weeks for which to retrieve the audit status count
     * - **audit_status**: audit status for which to retrieve the counts, defaults to True positive
     * - **return**: [DateCountModel]
     *     The output will contain a list of DateCountModel type objects
     */
    get: operations['get_finding_audit_count_over_time_resc_v1_metrics_audited_count_over_time_get'];
  };
  '/resc/v1/metrics/count-per-vcs-provider-by-week': {
    /**
     * Get count of findings over time for given weeks per vcs provider
     * @description Retrieve count of findings over time for given weeks per vcs provider
     * - **db_connection**: Session of the database connection
     * - **weeks**: Nr of weeks for which to retrieve the audit status count
     * - **audit_status**: audit status for which to retrieve the counts, defaults to True positive
     * - **return**: [DateCountModel]
     *     The output will contain a list of DateCountModel type objects
     */
    get: operations['get_finding_total_count_over_time_resc_v1_metrics_count_per_vcs_provider_by_week_get'];
  };
  '/resc/v1/metrics/un-triaged-count-over-time': {
    /**
     * Get count of UnTriaged findings over time for given weeks per vcs provider
     * @description Retrieve count of UnTriaged findings over time for given weeks per vcs provider
     * - **db_connection**: Session of the database connection
     * - **weeks**: Nr of weeks for which to retrieve the audit status count
     * - **audit_status**: audit status for which to retrieve the counts, defaults to True positive
     * - **return**: [DateCountModel]
     *     The output will contain a list of DateCountModel type objects
     */
    get: operations['get_finding_un_triaged_count_over_time_resc_v1_metrics_un_triaged_count_over_time_get'];
  };
  '/resc/v1/metrics/audit-count-by-auditor-over-time': {
    /**
     * Get count of Audits by Auditor over time for given weeks
     * @description Retrieve count of Audits by Auditor over time for given weeks
     * - **db_connection**: Session of the database connection
     * - **weeks**: Nr of weeks for which to retrieve the audit counts
     * - **return**: [AuditCountOverTime]
     *     The output will contain a list of AuditCountOverTime type objects
     */
    get: operations['get_audit_count_by_auditor_over_time_resc_v1_metrics_audit_count_by_auditor_over_time_get'];
  };
  '/resc/v1/metrics/personal-audits': {
    /**
     * Get personal audit metrics
     * @description Retrieve personal audit metrics
     * - **db_connection**: Session of the database connection
     * - **return**: [DateCountModel]
     *     The output will contain a PersonalAuditMetrics type objects
     */
    get: operations['get_personal_audit_metrics_resc_v1_metrics_personal_audits_get'];
  };
  '/': {
    /** View Docs */
    get: operations['view_docs__get'];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /** AuditCountOverTime */
    AuditCountOverTime: {
      /** Time Period */
      time_period: string;
      /** Audit By Auditor Count */
      audit_by_auditor_count: {
        [key: string]: number;
      };
      /**
       * Total
       * @default 0
       */
      total?: number;
    };
    /** AuditMultiple */
    AuditMultiple: {
      /** Finding Ids */
      finding_ids: number[];
      status: components['schemas']['FindingStatus'];
      /** Comment */
      comment: string;
    };
    /** AuditRead */
    AuditRead: {
      /** Id */
      id_: number;
      status: components['schemas']['FindingStatus'];
      /** Auditor */
      auditor: string;
      /** Comment */
      comment?: string;
      /**
       * Timestamp
       * Format: date-time
       */
      timestamp: string;
    };
    /** Body_upload_rule_pack_toml_file_resc_v1_rule_packs_post */
    Body_upload_rule_pack_toml_file_resc_v1_rule_packs_post: {
      /**
       * Rule File
       * Format: binary
       */
      rule_file: string;
    };
    /** DateCountModel */
    DateCountModel: {
      /** Date Lable */
      date_lable: string;
      /**
       * Finding Count
       * @default 0
       */
      finding_count?: number;
    };
    /**
     * DateFilter
     * @description An enumeration.
     * @enum {string}
     */
    DateFilter: 'month' | 'week' | 'day';
    /** DetailedFindingRead */
    DetailedFindingRead: {
      /** File Path */
      file_path: string;
      /** Line Number */
      line_number: number;
      /** Column Start */
      column_start: number;
      /** Column End */
      column_end: number;
      /** Commit Id */
      commit_id: string;
      /** Commit Message */
      commit_message: string;
      /**
       * Commit Timestamp
       * Format: date-time
       */
      commit_timestamp: string;
      /** Author */
      author: string;
      /** Email */
      email: string;
      /** @default NOT_ANALYZED */
      status?: components['schemas']['FindingStatus'];
      /** Comment */
      comment?: string;
      /** Rule Name */
      rule_name: string;
      /** Rule Pack */
      rule_pack: string;
      /** Project Key */
      project_key: string;
      /** Repository Name */
      repository_name: string;
      /**
       * Repository Url
       * Format: uri
       */
      repository_url: string;
      /**
       * Timestamp
       * Format: date-time
       */
      timestamp: string;
      vcs_provider: components['schemas']['VCSProviders'];
      /** Last Scanned Commit */
      last_scanned_commit: string;
      /** Scan Id */
      scan_id: number;
      /**
       * Event Sent On
       * Format: date-time
       */
      event_sent_on?: string;
      /** Id */
      id_: number;
      /** Commit Url */
      commit_url?: string;
    };
    /**
     * FindingCountModel[RepositoryRead]
     * @description     Generic encapsulation class for findings count end points to standardize output of the API
     *     example creation, FindingCountModel[FindingRead](data=db_findings, true_positive=true_positive,
     *     false_positive=false_positive, not_analyzed=not_analyzed, under_review=under_review,
     *     clarification_required=clarification_required, total_findings_count=total_findings_count)
     * :param Generic[Model]:
     *     Type of the object in the data list
     */
    FindingCountModel_RepositoryRead_: {
      data?: components['schemas']['RepositoryRead'];
      /** True Positive */
      true_positive: number;
      /** False Positive */
      false_positive: number;
      /** Not Analyzed */
      not_analyzed: number;
      /** Under Review */
      under_review: number;
      /** Clarification Required */
      clarification_required: number;
      /** Total Findings Count */
      total_findings_count: number;
    };
    /** FindingCountOverTime */
    FindingCountOverTime: {
      /** Time Period */
      time_period: string;
      /**
       * Vcs Provider Finding Count
       * @default {
       *   "AZURE_DEVOPS": 0,
       *   "BITBUCKET": 0,
       *   "GITHUB_PUBLIC": 0
       * }
       */
      vcs_provider_finding_count?: components['schemas']['VcsProviderFindingCount'];
      /**
       * Total
       * @default 0
       */
      total?: number;
    };
    /** FindingCreate */
    FindingCreate: {
      /** File Path */
      file_path: string;
      /** Line Number */
      line_number: number;
      /** Column Start */
      column_start: number;
      /** Column End */
      column_end: number;
      /** Commit Id */
      commit_id: string;
      /** Commit Message */
      commit_message: string;
      /**
       * Commit Timestamp
       * Format: date-time
       */
      commit_timestamp: string;
      /** Author */
      author: string;
      /** Email */
      email: string;
      /**
       * Event Sent On
       * Format: date-time
       */
      event_sent_on?: string;
      /** Rule Name */
      rule_name: string;
      /** Repository Id */
      repository_id: number;
    };
    /** FindingPatch */
    FindingPatch: {
      /**
       * Event Sent On
       * Format: date-time
       */
      event_sent_on: string;
    };
    /** FindingRead */
    FindingRead: {
      /** File Path */
      file_path: string;
      /** Line Number */
      line_number: number;
      /** Column Start */
      column_start: number;
      /** Column End */
      column_end: number;
      /** Commit Id */
      commit_id: string;
      /** Commit Message */
      commit_message: string;
      /**
       * Commit Timestamp
       * Format: date-time
       */
      commit_timestamp: string;
      /** Author */
      author: string;
      /** Email */
      email: string;
      /**
       * Event Sent On
       * Format: date-time
       */
      event_sent_on?: string;
      /** Rule Name */
      rule_name: string;
      /** Repository Id */
      repository_id: number;
      /** Id */
      id_: number;
      /** Scan Ids */
      scan_ids?: number[];
    };
    /**
     * FindingStatus
     * @description An enumeration.
     * @enum {string}
     */
    FindingStatus:
      | 'NOT_ANALYZED'
      | 'UNDER_REVIEW'
      | 'CLARIFICATION_REQUIRED'
      | 'FALSE_POSITIVE'
      | 'TRUE_POSITIVE';
    /** HTTPValidationError */
    HTTPValidationError: {
      /** Detail */
      detail?: components['schemas']['ValidationError'][];
    };
    /**
     * Model400
     * @description Response schema to be used for a 400 BAD REQUEST.
     * @example {
     *   "detail": "Bad Request"
     * }
     */
    Model400: Record<string, never>;
    /**
     * Model404
     * @description Response schema to be used for a 404 NOT FOUND.
     * @example {
     *   "data": {},
     *   "detail": "<id> not found"
     * }
     */
    Model404: Record<string, never>;
    /**
     * Model409
     * @description Response schema to be used for a 409 CONFLICT.
     * @example {
     *   "detail": "Unable to process entity due to conflict"
     * }
     */
    Model409: Record<string, never>;
    /**
     * Model422
     * @description Response schema to be used for a 422 UNPROCESSABLE ENTITY.
     * @example {
     *   "detail": "Entity cannot be processed"
     * }
     */
    Model422: Record<string, never>;
    /**
     * PaginationModel[AuditRead]
     * @description     Generic encapsulation class for paginated endpoints to standardize output of the API
     *     example creation, PaginationModel[FindingRead](data=db_findings, total=total, limit=limit, skip=skip)
     * :param Generic[Model]:
     *     Type of the object in the data list
     */
    PaginationModel_AuditRead_: {
      /** Data */
      data: components['schemas']['AuditRead'][];
      /** Total */
      total: number;
      /** Limit */
      limit: number;
      /** Skip */
      skip: number;
    };
    /**
     * PaginationModel[DateCountModel]
     * @description     Generic encapsulation class for paginated endpoints to standardize output of the API
     *     example creation, PaginationModel[FindingRead](data=db_findings, total=total, limit=limit, skip=skip)
     * :param Generic[Model]:
     *     Type of the object in the data list
     */
    PaginationModel_DateCountModel_: {
      /** Data */
      data: components['schemas']['DateCountModel'][];
      /** Total */
      total: number;
      /** Limit */
      limit: number;
      /** Skip */
      skip: number;
    };
    /**
     * PaginationModel[DetailedFindingRead]
     * @description     Generic encapsulation class for paginated endpoints to standardize output of the API
     *     example creation, PaginationModel[FindingRead](data=db_findings, total=total, limit=limit, skip=skip)
     * :param Generic[Model]:
     *     Type of the object in the data list
     */
    PaginationModel_DetailedFindingRead_: {
      /** Data */
      data: components['schemas']['DetailedFindingRead'][];
      /** Total */
      total: number;
      /** Limit */
      limit: number;
      /** Skip */
      skip: number;
    };
    /**
     * PaginationModel[FindingRead]
     * @description     Generic encapsulation class for paginated endpoints to standardize output of the API
     *     example creation, PaginationModel[FindingRead](data=db_findings, total=total, limit=limit, skip=skip)
     * :param Generic[Model]:
     *     Type of the object in the data list
     */
    PaginationModel_FindingRead_: {
      /** Data */
      data: components['schemas']['FindingRead'][];
      /** Total */
      total: number;
      /** Limit */
      limit: number;
      /** Skip */
      skip: number;
    };
    /**
     * PaginationModel[RepositoryEnrichedRead]
     * @description     Generic encapsulation class for paginated endpoints to standardize output of the API
     *     example creation, PaginationModel[FindingRead](data=db_findings, total=total, limit=limit, skip=skip)
     * :param Generic[Model]:
     *     Type of the object in the data list
     */
    PaginationModel_RepositoryEnrichedRead_: {
      /** Data */
      data: components['schemas']['RepositoryEnrichedRead'][];
      /** Total */
      total: number;
      /** Limit */
      limit: number;
      /** Skip */
      skip: number;
    };
    /**
     * PaginationModel[RepositoryRead]
     * @description     Generic encapsulation class for paginated endpoints to standardize output of the API
     *     example creation, PaginationModel[FindingRead](data=db_findings, total=total, limit=limit, skip=skip)
     * :param Generic[Model]:
     *     Type of the object in the data list
     */
    PaginationModel_RepositoryRead_: {
      /** Data */
      data: components['schemas']['RepositoryRead'][];
      /** Total */
      total: number;
      /** Limit */
      limit: number;
      /** Skip */
      skip: number;
    };
    /**
     * PaginationModel[RulePackRead]
     * @description     Generic encapsulation class for paginated endpoints to standardize output of the API
     *     example creation, PaginationModel[FindingRead](data=db_findings, total=total, limit=limit, skip=skip)
     * :param Generic[Model]:
     *     Type of the object in the data list
     */
    PaginationModel_RulePackRead_: {
      /** Data */
      data: components['schemas']['RulePackRead'][];
      /** Total */
      total: number;
      /** Limit */
      limit: number;
      /** Skip */
      skip: number;
    };
    /**
     * PaginationModel[ScanRead]
     * @description     Generic encapsulation class for paginated endpoints to standardize output of the API
     *     example creation, PaginationModel[FindingRead](data=db_findings, total=total, limit=limit, skip=skip)
     * :param Generic[Model]:
     *     Type of the object in the data list
     */
    PaginationModel_ScanRead_: {
      /** Data */
      data: components['schemas']['ScanRead'][];
      /** Total */
      total: number;
      /** Limit */
      limit: number;
      /** Skip */
      skip: number;
    };
    /**
     * PaginationModel[VCSInstanceRead]
     * @description     Generic encapsulation class for paginated endpoints to standardize output of the API
     *     example creation, PaginationModel[FindingRead](data=db_findings, total=total, limit=limit, skip=skip)
     * :param Generic[Model]:
     *     Type of the object in the data list
     */
    PaginationModel_VCSInstanceRead_: {
      /** Data */
      data: components['schemas']['VCSInstanceRead'][];
      /** Total */
      total: number;
      /** Limit */
      limit: number;
      /** Skip */
      skip: number;
    };
    /** PersonalAuditMetrics */
    PersonalAuditMetrics: {
      /**
       * Today
       * @default 0
       */
      today?: number;
      /**
       * Current Week
       * @default 0
       */
      current_week?: number;
      /**
       * Last Week
       * @default 0
       */
      last_week?: number;
      /**
       * Current Month
       * @default 0
       */
      current_month?: number;
      /**
       * Current Year
       * @default 0
       */
      current_year?: number;
      /**
       * Forever
       * @default 0
       */
      forever?: number;
      /**
       * Rank Current Week
       * @default 0
       */
      rank_current_week?: number;
    };
    /** RepositoryCreate */
    RepositoryCreate: {
      /** Project Key */
      project_key: string;
      /** Repository Id */
      repository_id: string;
      /** Repository Name */
      repository_name: string;
      /**
       * Repository Url
       * Format: uri
       */
      repository_url: string;
      /** Vcs Instance */
      vcs_instance: number;
    };
    /** RepositoryEnrichedRead */
    RepositoryEnrichedRead: {
      /** Project Key */
      project_key: string;
      /** Repository Id */
      repository_id: string;
      /** Repository Name */
      repository_name: string;
      /**
       * Repository Url
       * Format: uri
       */
      repository_url: string;
      vcs_provider: components['schemas']['VCSProviders'];
      /** Last Scan Id */
      last_scan_id?: number;
      /**
       * Last Scan Timestamp
       * Format: date-time
       */
      last_scan_timestamp?: string;
      /** True Positive */
      true_positive: number;
      /** False Positive */
      false_positive: number;
      /** Not Analyzed */
      not_analyzed: number;
      /** Under Review */
      under_review: number;
      /** Clarification Required */
      clarification_required: number;
      /** Total Findings Count */
      total_findings_count: number;
      /** Id */
      id_: number;
    };
    /** RepositoryRead */
    RepositoryRead: {
      /** Project Key */
      project_key: string;
      /** Repository Id */
      repository_id: string;
      /** Repository Name */
      repository_name: string;
      /**
       * Repository Url
       * Format: uri
       */
      repository_url: string;
      /** Vcs Instance */
      vcs_instance: number;
      /** Id */
      id_: number;
    };
    /**
     * RuleFindingCountModel
     * @description :param Generic[Model]:
     *     Type of the object in the data list
     */
    RuleFindingCountModel: {
      /** Rule Name */
      rule_name: string;
      /**
       * Finding Count
       * @default 0
       */
      finding_count?: number;
      /**
       * Finding Statuses Count
       * @default []
       */
      finding_statuses_count?: components['schemas']['StatusCount'][];
    };
    /** RulePackRead */
    RulePackRead: {
      /** Version */
      version: string;
      /**
       * Active
       * @default false
       */
      active?: boolean;
      /** Global Allow List */
      global_allow_list?: number;
      /**
       * Created
       * Format: date-time
       */
      created: string;
    };
    /** ScanCreate */
    ScanCreate: {
      /** @default BASE */
      scan_type?: components['schemas']['ScanType'];
      /** Last Scanned Commit */
      last_scanned_commit: string;
      /**
       * Timestamp
       * Format: date-time
       */
      timestamp: string;
      /**
       * Increment Number
       * @default 0
       */
      increment_number?: number;
      /** Rule Pack */
      rule_pack: string;
      /** Repository Id */
      repository_id: number;
    };
    /** ScanRead */
    ScanRead: {
      /** @default BASE */
      scan_type?: components['schemas']['ScanType'];
      /** Last Scanned Commit */
      last_scanned_commit: string;
      /**
       * Timestamp
       * Format: date-time
       */
      timestamp: string;
      /**
       * Increment Number
       * @default 0
       */
      increment_number?: number;
      /** Rule Pack */
      rule_pack: string;
      /** Repository Id */
      repository_id: number;
      /** Id */
      id_: number;
    };
    /**
     * ScanType
     * @description An enumeration.
     * @enum {string}
     */
    ScanType: 'BASE' | 'INCREMENTAL';
    /** StatusCount */
    StatusCount: {
      status: components['schemas']['FindingStatus'];
      /**
       * Count
       * @default 0
       */
      count?: number;
    };
    /** VCSInstanceCreate */
    VCSInstanceCreate: {
      /** Name */
      name: string;
      provider_type: components['schemas']['VCSProviders'];
      /** Hostname */
      hostname: string;
      /** Port */
      port: number;
      /** Scheme */
      scheme: string;
      /** Exceptions */
      exceptions?: string[];
      /** Scope */
      scope?: string[];
      /** Organization */
      organization?: string;
    };
    /** VCSInstanceRead */
    VCSInstanceRead: {
      /** Name */
      name: string;
      provider_type: components['schemas']['VCSProviders'];
      /** Hostname */
      hostname: string;
      /** Port */
      port: number;
      /** Scheme */
      scheme: string;
      /** Exceptions */
      exceptions?: string[];
      /** Scope */
      scope?: string[];
      /** Organization */
      organization?: string;
      /** Id */
      id_: number;
    };
    /**
     * VCSProviders
     * @description An enumeration.
     * @enum {string}
     */
    VCSProviders: 'AZURE_DEVOPS' | 'BITBUCKET' | 'GITHUB_PUBLIC';
    /** ValidationError */
    ValidationError: {
      /** Location */
      loc: (string | number)[];
      /** Message */
      msg: string;
      /** Error Type */
      type: string;
    };
    /** VcsProviderFindingCount */
    VcsProviderFindingCount: {
      /**
       * Azure Devops
       * @default 0
       */
      AZURE_DEVOPS?: number;
      /**
       * Bitbucket
       * @default 0
       */
      BITBUCKET?: number;
      /**
       * Github Public
       * @default 0
       */
      GITHUB_PUBLIC?: number;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {
  /**
   * Health check
   * @description Retrieve the health status of RESC APIs
   */
  health_check_resc_v1_health_get: {
    responses: {
      /** @description Retrieve the health status */
      200: {
        content: {
          'application/json': unknown;
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get supported vcs-providers
   * @description Retrieve the supported vcs-providers, example: Bitbucket, AzureDevOps, Github etc
   */
  get_supported_vcs_providers_resc_v1_supported_vcs_providers_get: {
    responses: {
      /** @description Retrieve the supported vcs-providers */
      200: {
        content: {
          'application/json': string[];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Authorization check
   * @description The output returns 200 OK if auth check is successful else returns 403 Forbidden
   */
  auth_check_resc_v1_auth_check_get: {
    responses: {
      /** @description Validate authorization check from the access-token */
      200: {
        content: {
          'application/json': unknown;
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get unique rules from findings
   * @description Retrieve all uniquely detected rules across all findings in the database
   *
   * - **db_connection**: Session of the database connection
   * - **finding_statuses**: Optional, filter on supported finding statuses
   * - **vcs_providers**: Optional, filter on supported vcs provider types
   * - **project_name**: Optional, filter on project name. It is used as a full string match filter
   * - **repository_name**: Optional, filter on repository name. It is used as a string contains filter
   * - **start_date_time**: Optional, filter on start date
   * - **end_date_time**: Optional, filter on end date
   * - **rule_pack_version**: Optional, filter on rule pack version
   * - **return**: List[str] The output will contain a list of strings of unique rules in the findings table
   */
  get_distinct_rules_from_findings_resc_v1_detected_rules_get: {
    parameters: {
      query?: {
        findingstatus?: components['schemas']['FindingStatus'][];
        vcsprovider?: components['schemas']['VCSProviders'][];
        project_name?: string;
        repository_name?: string;
        start_date_time?: string;
        end_date_time?: string;
        rule_pack_version?: string[];
      };
    };
    responses: {
      /** @description Retrieve all the unique detected rules across all the findings */
      200: {
        content: {
          'application/json': string[];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get detected rules with counts per status
   * @description Retrieve all detected rules with finding counts per supported status
   *
   * - **rule_pack_version**: Optional, filter on rule pack version
   * - **rule_tag**: Optional, filter on rule tag
   * - **db_connection**: Session of the database connection
   * - **return**: List[str] The output will contain a list of strings of unique rules with counts per status
   */
  get_rules_finding_status_count_resc_v1_rules_finding_status_count_get: {
    parameters: {
      query?: {
        rule_pack_version?: string[];
        rule_tag?: string[];
      };
    };
    responses: {
      /** @description Retrieve all the detected rules with counts per status */
      200: {
        content: {
          'application/json': components['schemas']['RuleFindingCountModel'][];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get rule packs
   * @description Retrieve rule packs
   *
   * - **db_connection**: Session of the database connection
   * - **version**: Optional, filter on rule pack version
   * - **active**: Optional, filter on active rule pack
   * - **skip**: Integer amount of records to skip, to support pagination
   * - **limit**: Integer amount of records to return, to support pagination
   * - **return**: [RulePackRead]
   *     The output will contain a PaginationModel containing the list of RulePackRead type objects,
   *     or an empty list if no rule pack was found
   */
  get_rule_packs_resc_v1_rule_packs_versions_get: {
    parameters: {
      query?: {
        version?: string;
        /** @description Filter on active rule packs */
        active?: boolean;
        skip?: number;
        limit?: number;
      };
    };
    responses: {
      /** @description Retrieve all the rule-packs */
      200: {
        content: {
          'application/json': components['schemas']['PaginationModel_RulePackRead_'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Download rule pack in TOML format
   * @description Download rule pack in TOML format
   *
   * - **db_connection**: Session of the database connection
   * - **version**: Optional, filter on rule pack version
   * - **return**: [FileResponse] The output returns rule pack file downloaded in TOML format
   */
  download_rule_pack_toml_file_resc_v1_rule_packs_get: {
    parameters: {
      query?: {
        version?: string;
      };
    };
    responses: {
      /** @description Download the rule-pack in TOML format */
      200: {
        content: {
          'application/json': unknown;
        };
      };
      /** @description No rule-pack of version <version_id> found */
      404: {
        content: {
          'application/json': components['schemas']['Model404'];
        };
      };
      /** @description Version <version_id> is not a valid semantic version */
      422: {
        content: {
          'application/json': components['schemas']['Model422'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Upload rule pack in TOML format
   * @description Upload TOML rule pack to database
   *
   * - **db_connection**: Session of the database connection
   * - **version**: Version of the rule pack to be uploaded
   * - **rule_file**: TOML rule pack file to be uploaded
   * - **return**: dict The output returns uploaded rule pack name in dictionary format
   */
  upload_rule_pack_toml_file_resc_v1_rule_packs_post: {
    parameters: {
      query: {
        version: string;
      };
    };
    requestBody: {
      content: {
        'multipart/form-data': components['schemas']['Body_upload_rule_pack_toml_file_resc_v1_rule_packs_post'];
      };
    };
    responses: {
      /** @description Upload the rule-pack in TOML format */
      200: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      /** @description No properties defined for rule allow list */
      400: {
        content: {
          'application/json': components['schemas']['Model400'];
        };
      };
      /** @description Rule-pack version <version_id> already exists */
      409: {
        content: {
          'application/json': components['schemas']['Model409'];
        };
      };
      /** @description Version <version_id> is not a valid semantic version */
      422: {
        content: {
          'application/json': components['schemas']['Model422'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get rule packs' tags
   * @description Retrieve rule pack related tags
   *
   * :param db_connection: Session of the database connection
   * :param versions: Optional, filter on rule pack version, if not provided filter on active.
   * :return: List[str]
   *     The output will contain a list of tags related to one or more rule-packs.
   */
  get_rule_packs_tags_resc_v1_rule_packs_tags_get: {
    parameters: {
      query?: {
        version?: string[];
      };
    };
    responses: {
      /** @description Retrieve all the tags related to a rule-pack[s] */
      200: {
        content: {
          'application/json': string[];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get findings
   * @description Retrieve all findings objects paginated
   *
   * - **db_connection**: Session of the database connection
   * - **skip**: Integer amount of records to skip to support pagination
   * - **limit**: Integer amount of records to return, to support pagination
   * - **return**: [FindingRead]
   *     The output will contain a PaginationModel containing the list of FindingRead type objects,
   *     or an empty list if no finding was found
   */
  get_all_findings_resc_v1_findings_get: {
    parameters: {
      query?: {
        skip?: number;
        limit?: number;
      };
    };
    responses: {
      /** @description Retrieve all the findings */
      200: {
        content: {
          'application/json': components['schemas']['PaginationModel_FindingRead_'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Create a finding
   * @description Create new findings
   *
   * - **db_connection**: Session of the database connection
   * - **file_path**: file path
   * - **line_number**: Line number
   * - **commit_id**: commit hash
   * - **commit_message**: Commit message
   * - **commit_timestamp**: Commit timestamp
   * - **author**: Author name
   * - **email**: Email of the author
   * - **event_sent_on**: event sent timestamp
   * - **rule_name**: rule name
   * - **repository_id**: repository id of the finding
   * - **return**: int
   *       The output will contain the number of successful created findings
   */
  create_findings_resc_v1_findings_post: {
    requestBody: {
      content: {
        'application/json': components['schemas']['FindingCreate'][];
      };
    };
    responses: {
      /** @description Create new findings */
      201: {
        content: {
          'application/json': number;
        };
      };
      /** @description Error creating findings */
      400: {
        content: {
          'application/json': components['schemas']['Model400'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Fetch a finding by ID
   * @description Read a finding by ID
   *
   * - **db_connection**: Session of the database connection
   * - **finding_id**: ID of the finding for which details need to be fetched
   */
  read_finding_resc_v1_findings__finding_id__get: {
    parameters: {
      path: {
        finding_id: number;
      };
    };
    responses: {
      /** @description Retrieve finding <finding_id> */
      200: {
        content: {
          'application/json': components['schemas']['FindingRead'];
        };
      };
      /** @description Finding <finding_id> not found */
      404: {
        content: {
          'application/json': components['schemas']['Model404'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Delete a finding
   * @description Delete a finding object
   *
   * - **db_connection**: Session of the database connection
   * - **finding_id**: ID of the finding to delete
   * - **return**: The output will contain a success or error message based on the success of the deletion
   */
  delete_finding_resc_v1_findings__finding_id__delete: {
    parameters: {
      path: {
        finding_id: number;
      };
    };
    responses: {
      /** @description Delete finding <finding_id> */
      200: {
        content: {
          'application/json': unknown;
        };
      };
      /** @description Finding <finding_id> not found */
      404: {
        content: {
          'application/json': components['schemas']['Model404'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Partially update a finding by ID
   * @description Partially update a finding by ID
   *
   * - **db_connection**: Session of the database connection
   * - **finding_id**: ID of the finding for which details need to be updated
   * - **event_sent_on**: Event sent timestamp
   */
  patch_finding_resc_v1_findings__finding_id__patch: {
    parameters: {
      path: {
        finding_id: number;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FindingPatch'];
      };
    };
    responses: {
      /** @description Modify finding <finding_id> */
      200: {
        content: {
          'application/json': components['schemas']['FindingRead'];
        };
      };
      /** @description Finding <finding_id> not found */
      404: {
        content: {
          'application/json': components['schemas']['Model404'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get total findings count by rule
   * @description Retrieve total findings count for a given rule
   *
   * - **db_connection**: Session of the database connection
   * - **rule_name**: name of the rule
   */
  get_total_findings_count_by_rule_resc_v1_findings_total_count_by_rule__rule_name__get: {
    parameters: {
      path: {
        rule_name: string;
      };
    };
    responses: {
      /** @description Retrieve total findings count of rule <rule_name> */
      200: {
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get findings by rule
   * @description Retrieve all findings objects paginated by rule
   *
   * - **db_connection**: Session of the database connection
   * - **rule_name**: Name of the rule to filter the findings by
   * - **skip**: Integer amount of records to skip to support pagination
   * - **limit**: Integer amount of records to return, to support pagination
   * - **return**: [FindingRead]
   *     The output will contain a PaginationModel containing the list of FindingRead type objects,
   *     or an empty list if no finding was found for the given rule
   */
  get_findings_by_rule_resc_v1_findings_by_rule__rule_name__get: {
    parameters: {
      query?: {
        skip?: number;
        limit?: number;
      };
      path: {
        rule_name: string;
      };
    };
    responses: {
      /** @description Retrieve all the findings of rule <rule_name> */
      200: {
        content: {
          'application/json': components['schemas']['PaginationModel_FindingRead_'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * audit single/multiple findings
   * @description Audit single/multiple findings, updating the status and comment
   *
   * - **db_connection**: Session of the database connection
   * - **finding_ids**: List of finding IDs for which audit to be performed
   * - **status**: Status of the finding, Valid values are NOT_ANALYZED, UNDER_REVIEW,
   *               CLARIFICATION_REQUIRED, FALSE_POSITIVE, TRUE_POSITIVE
   * - **comment**: Comment
   * - **return**: int
   *     The output will contain count of successful saved audits
   */
  audit_findings_resc_v1_findings_audit__post: {
    requestBody: {
      content: {
        'application/json': components['schemas']['AuditMultiple'];
      };
    };
    responses: {
      /** @description Audit(s) successfully saved */
      201: {
        content: {
          'application/json': number;
        };
      };
      /** @description Finding <finding_id> not found */
      404: {
        content: {
          'application/json': components['schemas']['Model404'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get audit(s) for finding
   * @description Retrieve all audit objects paginated for a finding
   *
   * - **db_connection**: Session of the database connection
   * - **finding_id**: id of the finding to get the audit for
   * - **skip**: Integer amount of records to skip to support pagination
   * - **limit**: Integer amount of records to return, to support pagination
   * - **return**: [AuditRead]
   *     The output will contain a PaginationModel containing the list of AuditRead type objects,
   *     or an empty list if no audit info was found
   */
  get_finding_audits_resc_v1_findings__finding_id__audit_get: {
    parameters: {
      query?: {
        skip?: number;
        limit?: number;
      };
      path: {
        finding_id: number;
      };
    };
    responses: {
      /** @description Retrieve all the audit entries for a finding */
      200: {
        content: {
          'application/json': components['schemas']['PaginationModel_AuditRead_'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get all supported statuses for findings
   * @description Retrieve all supported statuses for findings
   *
   * - **return**: List[str]
   *     The output will contain a list of strings of unique statuses supported
   */
  get_supported_statuses_resc_v1_findings_supported_statuses__get: {
    responses: {
      /** @description Retrieve all the supported statuses for the findings */
      200: {
        content: {
          'application/json': string[];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get all the findings by time period
   * @description Retrieve all findings count by time period objects paginated
   *
   * - **db_connection**: Session of the database connection
   * - **time_type**: required, filter on time type. Available values: month, week, day
   * - **skip**: Integer amount of records to skip to support pagination
   * - **limit**: Integer amount of records to return, to support pagination
   * - **start_date_time**: Optional, filter on start date
   * - **end_date_time**: Optional, filter on end date
   * - **return**: PaginationModel[DateCountModel]
   *     The output will contain a PaginationModel containing the list of DateCountModel type objects,
   *     or an empty list if no data was found
   */
  get_count_by_time_resc_v1_findings_count_by_time__time_type__get: {
    parameters: {
      query?: {
        skip?: number;
        limit?: number;
        start_date_time?: string;
        end_date_time?: string;
      };
      path: {
        time_type: components['schemas']['DateFilter'];
      };
    };
    responses: {
      /** @description Retrieve all the findings by time-period <time_type> */
      200: {
        content: {
          'application/json': components['schemas']['PaginationModel_DateCountModel_'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get all detailed findings
   * @description Retrieve all findings objects paginated
   * - **query_string**
   *
   *     A query string with the following format:
   *         param1=value1&param2=value2&param3=value3
   *
   *     Where the possible parameters are:
   *
   *         - vcs_providers [enum] of type VCSProviders, possible values are: BITBUCKET, AZURE_DEVOPS.
   *             Will default to all if non-specified.
   *
   *         - finding_statuses [enum of type FindingStatus], possible values are:NOT_ANALYZED,FALSE_POSITIVE,
   *           TRUE_POSITIVE. Will default to all if non-specified.
   *
   *         - rule_pack_versions of type [String]
   *
   *         - rule_names of type [String]
   *
   *         - rule_tags of type [String] findings in the result will have at least one of the specified tags
   *           for the rules
   *
   *         - project_name of type String
   *
   *         - repository_names of type [String]
   *
   *         - scan_ids of type list Integer
   *
   *         - start_date_time of type datetime with the following format: 1970-01-31T00:00:00
   *
   *         - end_date_time of type datetime with the following format: 1970-01-31T00:00:00
   *
   * - **db_connection**
   *
   *     Session of the database connection
   *
   * - **skip**
   *
   *     Integer amount of records to skip to support pagination
   *
   * - **limit**
   *
   *     Integer amount of records to return, to support pagination
   *
   * - **return** [FindingRead]
   *
   *     The output will contain a PaginationModel containing the list of DetailedFinding type objects,
   *     or an empty list if no finding was found
   */
  get_all_detailed_findings_resc_v1_detailed_findings_get: {
    parameters: {
      query?: {
        skip?: number;
        limit?: number;
        query_string?: string;
      };
    };
    responses: {
      /** @description Retrieve all the findings */
      200: {
        content: {
          'application/json': components['schemas']['PaginationModel_DetailedFindingRead_'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Fetch detailed finding by ID
   * @description Retrieve detailed finding by its ID
   *
   * - **db_connection**: Session of the database connection
   * - **finding_id**: ID of the finding for which details need to be fetched
   * - **return**: [DetailedFindingRead]
   *     The output will contain the details of a finding
   */
  read_finding_resc_v1_detailed_findings__finding_id__get: {
    parameters: {
      path: {
        finding_id: number;
      };
    };
    responses: {
      /** @description Retrieve detailed finding <finding_id> */
      200: {
        content: {
          'application/json': components['schemas']['DetailedFindingRead'];
        };
      };
      /** @description Finding <finding_id> not found */
      404: {
        content: {
          'application/json': components['schemas']['Model404'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get repositories
   * @description Retrieve all repository objects paginated
   *
   * - **db_connection**: Session of the database connection
   * - **skip**: Integer amount of records to skip to support pagination
   * - **limit**: Integer amount of records to return, to support pagination
   * - **vcsproviders**: Optional, filter on supported vcs provider types
   * - **projectfilter**: Optional, filter on project name. It is used as a string contains filter
   * - **repositoryfilter**: Optional, filter on repository name. It is used as a string contains filter
   * - **return**: [RepositoryRead]
   *     The output will contain a PaginationModel containing the list of RepositoryRead type objects,
   *     or an empty list if no repository
   */
  get_all_repositories_resc_v1_repositories_get: {
    parameters: {
      query?: {
        skip?: number;
        limit?: number;
        vcsprovider?: components['schemas']['VCSProviders'][];
        projectfilter?: string;
        repositoryfilter?: string;
      };
    };
    responses: {
      /** @description Retrieve all the repositories */
      200: {
        content: {
          'application/json': components['schemas']['PaginationModel_RepositoryRead_'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Create a repository
   * @description Create a repository with all the information
   *
   * - **db_connection**: Session of the database connection
   * - **project_key**: each repository must have a project name or key
   * - **repository_id**: repository id
   * - **repository_name**: repository name
   * - **repository_url**: repository url
   * - **vcs_instance**: vcs instance id
   */
  create_repository_resc_v1_repositories_post: {
    requestBody: {
      content: {
        'application/json': components['schemas']['RepositoryCreate'];
      };
    };
    responses: {
      /** @description Create a new repository */
      201: {
        content: {
          'application/json': components['schemas']['RepositoryRead'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Fetch a repository by ID
   * @description Read a repository by ID
   *
   * - **db_connection**: Session of the database connection
   * - **repository_id**: ID of the repository for which details need to be fetched
   */
  read_repository_resc_v1_repositories__repository_id__get: {
    parameters: {
      path: {
        repository_id: number;
      };
    };
    responses: {
      /** @description Retrieve repository <repository_id> */
      200: {
        content: {
          'application/json': components['schemas']['RepositoryRead'];
        };
      };
      /** @description Repository <repository_id> not found */
      404: {
        content: {
          'application/json': components['schemas']['Model404'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Update an existing repository
   * @description Update an existing repository
   *
   * - **db_connection**: Session of the database connection
   * - **repository_id**: ID of the repository
   * - **project_key**: project name that needs to be updated
   * - **repository_id**: repository id that needs to be updated
   * - **repository_name**: repository name that needs to be updated
   * - **repository_url**: repository url that needs to be updated
   * - **vcs_instance**: vcs instance id that needs to be updated
   */
  update_repository_resc_v1_repositories__repository_id__put: {
    parameters: {
      path: {
        repository_id: number;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RepositoryCreate'];
      };
    };
    responses: {
      /** @description Update repository <repository_id> */
      200: {
        content: {
          'application/json': components['schemas']['RepositoryRead'];
        };
      };
      /** @description Repository <repository_id> not found */
      404: {
        content: {
          'application/json': components['schemas']['Model404'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Delete a repository
   * @description Delete a repository
   *
   * - **db_connection**: Session of the database connection
   * - **repository_id**: ID of the repository to delete
   * - **return**: The output will contain a success or error message based on the success of the deletion
   */
  delete_repository_resc_v1_repositories__repository_id__delete: {
    parameters: {
      path: {
        repository_id: number;
      };
    };
    responses: {
      /** @description Delete repository <repository_id> */
      200: {
        content: {
          'application/json': unknown;
        };
      };
      /** @description Repository <repository_id> not found */
      404: {
        content: {
          'application/json': components['schemas']['Model404'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get all unique project names
   * @description Retrieve all unique project names
   *
   * - **db_connection**: Session of the database connection
   * - **vcsproviders**: Optional, filter on supported vcs provider types
   * - **repositoryfilter**: Optional, filter on repository name. It is used as a string contains filter
   * - **onlyifhasfindings**: Optional, filter all projects those have findings
   * - **return**: List[str]
   *     The output will contain a list of unique projects
   */
  get_distinct_projects_resc_v1_repositories_distinct_projects__get: {
    parameters: {
      query?: {
        vcsprovider?: components['schemas']['VCSProviders'][];
        repositoryfilter?: string;
        onlyifhasfindings?: boolean;
      };
    };
    responses: {
      /** @description Retrieve all the unique project-names */
      200: {
        content: {
          'application/json': string[];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get all unique repository names
   * @description Retrieve all unique repository names
   *
   * - **db_connection**: Session of the database connection
   * - **vcsproviders**: Optional, filter of supported vcs provider types
   * - **projectname**: Optional, filter on project name. It is used as a full string match filter
   * - **onlyifhasfindings**: Optional, filter all repositories that have findings
   * - **return**: List[str]
   *     The output will contain a list of unique repositories
   */
  get_distinct_repositories_resc_v1_repositories_distinct_repositories__get: {
    parameters: {
      query?: {
        vcsprovider?: components['schemas']['VCSProviders'][];
        projectname?: string;
        onlyifhasfindings?: boolean;
      };
    };
    responses: {
      /** @description Retrieve all the unique repository names */
      200: {
        content: {
          'application/json': string[];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get findings metadata for a repository
   * @description Retrieve findings metadata for a repository
   *
   * - **db_connection**: Session of the database connection
   * - **repository_id**: ID of the repository object for which findings metadata to be retrieved
   * - **return**: RepositoryRead, findings count per status
   *     The output will contain a RepositoryRead type object along with findings count per status,
   *     or empty if no scan was found
   */
  get_findings_metadata_for_repository_resc_v1_repositories__repository_id__findings_metadata_get: {
    parameters: {
      path: {
        repository_id: number;
      };
    };
    responses: {
      /** @description Retrieve findings metadata for repository <repository_id> */
      200: {
        content: {
          'application/json': components['schemas']['FindingCountModel_RepositoryRead_'];
        };
      };
      /** @description Repository <repository_id> not found */
      404: {
        content: {
          'application/json': components['schemas']['Model404'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get all repositories with findings metadata
   * @description Retrieve all repository objects paginated
   *
   * - **db_connection**: Session of the database connection
   * - **skip**: Integer amount of records to skip to support pagination
   * - **limit**: Integer amount of records to return, to support pagination
   * - **vcsproviders**: Optional, filter on supported vcs provider types
   * - **projectfilter**: Optional, filter on project name. It is used as a string contains filter
   * - **repositoryfilter**: Optional, filter on repository name. It is used as a string contains filter
   * - **onlyifhasfindings**: Optional, filter all repositories those have findings
   * - **return**: [RepositoryEnrichedRead]
   *     The output will contain a PaginationModel containing the list of RepositoryEnrichedRead type objects,
   *     or an empty list if no repository
   */
  get_all_repositories_with_findings_metadata_resc_v1_repositories_findings_metadata__get: {
    parameters: {
      query?: {
        skip?: number;
        limit?: number;
        vcsprovider?: components['schemas']['VCSProviders'][];
        projectfilter?: string;
        repositoryfilter?: string;
        onlyifhasfindings?: boolean;
      };
    };
    responses: {
      /** @description Retrieve all the findings metadata for all the repositories */
      200: {
        content: {
          'application/json': components['schemas']['PaginationModel_RepositoryEnrichedRead_'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get latest scan for repository
   * @description Retrieve the latest scan object related to a repository
   *
   * - **db_connection**: Session of the database connection
   * - **repository_id**: ID of the parent repository object for which scan objects to be retrieved
   * - **return**: ScanRead
   *     The output will contain a ScanRead type object,
   *     or empty if no scan was found
   */
  get_last_scan_for_repository_resc_v1_repositories__repository_id__last_scan_get: {
    parameters: {
      path: {
        repository_id: number;
      };
    };
    responses: {
      /** @description Retrieve the latest scan related to a repository */
      200: {
        content: {
          'application/json': components['schemas']['ScanRead'];
        };
      };
      /** @description Scan not found */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get scans for repository
   * @description Retrieve all scan objects related to a repository paginated
   *
   * - **db_connection**: Session of the database connection
   * - **repository_id**: ID of the parent repository object for which scan objects to be retrieved
   * - **skip**: Integer amount of records to skip to support pagination
   * - **limit**: Integer amount of records to return, to support pagination
   * - **return**: [ScanRead]
   *     The output will contain a PaginationModel containing the list of ScanRead type objects,
   *     or an empty list if no scan was found
   */
  get_scans_for_repository_resc_v1_repositories__repository_id__scans_get: {
    parameters: {
      query?: {
        skip?: number;
        limit?: number;
      };
      path: {
        repository_id: number;
      };
    };
    responses: {
      /** @description Retrieve all the scans related to a repository */
      200: {
        content: {
          'application/json': components['schemas']['PaginationModel_ScanRead_'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get scans
   * @description Retrieve all scan objects paginated
   *
   * - **db_connection**: Session of the database connection
   * - **skip**: Integer amount of records to skip to support pagination
   * - **limit**: Integer amount of records to return, to support pagination
   * - **return**: [ScanRead]
   *     The output will contain a PaginationModel containing the list of ScanRead type objects,
   *     or an empty list if no scan was found
   */
  get_all_scans_resc_v1_scans_get: {
    parameters: {
      query?: {
        skip?: number;
        limit?: number;
      };
    };
    responses: {
      /** @description Retrieve all the scan objects */
      200: {
        content: {
          'application/json': components['schemas']['PaginationModel_ScanRead_'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Create a scan
   * @description Create a scan with all the information
   *
   * - **db_connection**: Session of the database connection
   * - **scan_type**: scan type, supported values are BASE or INCREMENTAL
   * - **last_scanned_commit**: last scanned commit hash
   * - **timestamp**: creation timestamp
   * - **increment_number**: scan increment number
   * - **rule_pack**: rule pack version
   * - **repository_id**: repository id
   */
  create_scan_resc_v1_scans_post: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ScanCreate'];
      };
    };
    responses: {
      /** @description Create a new scan */
      201: {
        content: {
          'application/json': components['schemas']['ScanRead'];
        };
      };
      /** @description Error creating a new scan */
      400: {
        content: {
          'application/json': components['schemas']['Model400'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Fetch a scan by ID
   * @description Read a scan by ID
   *
   * - **db_connection**: Session of the database connection
   * - **scan_id**: ID of the scan for which details need to be fetched
   */
  read_scan_resc_v1_scans__scan_id__get: {
    parameters: {
      path: {
        scan_id: number;
      };
    };
    responses: {
      /** @description Retrieve scan <scan_id> */
      200: {
        content: {
          'application/json': components['schemas']['ScanRead'];
        };
      };
      /** @description Scan <scan_id> not found */
      404: {
        content: {
          'application/json': components['schemas']['Model404'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Update an existing scan
   * @description Update an existing scan
   *
   * - **db_connection**: Session of the database connection
   * - **scan_type**: scan type, supported values are BASE or INCREMENTAL
   * - **last_scanned_commit**: last scanned commit
   * - **timestamp**: scan timestamp
   * - **increment_number**: scan increment number
   * - **rule_pack**: rule pack version
   * - **repository_id**: repository id
   */
  update_scan_resc_v1_scans__scan_id__put: {
    parameters: {
      path: {
        scan_id: number;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ScanCreate'];
      };
    };
    responses: {
      /** @description Update scan <scan_id> */
      200: {
        content: {
          'application/json': components['schemas']['ScanRead'];
        };
      };
      /** @description Scan <scan_id> not found */
      404: {
        content: {
          'application/json': components['schemas']['Model404'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Delete a scan
   * @description Delete a scan object
   *
   * - **db_connection**: Session of the database connection
   * - **scan_id**: ID of the scan to delete
   * - **return**: The output will contain a success or error message based on the success of the deletion
   */
  delete_scan_resc_v1_scans__scan_id__delete: {
    parameters: {
      path: {
        scan_id: number;
      };
    };
    responses: {
      /** @description Delete scan <scan_id> */
      200: {
        content: {
          'application/json': unknown;
        };
      };
      /** @description Scan <scan_id> not found */
      404: {
        content: {
          'application/json': components['schemas']['Model404'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get scan findings associated with a scan ID
   * @description Retrieve all finding objects paginated related to a scan_id
   *
   * - **db_connection**: Session of the database connection
   * - **scan_id**: Id of the scan for which to retrieve the findings
   * - **skip**: Integer amount of records to skip to support pagination
   * - **limit**: Integer amount of records to return, to support pagination
   * - **rules**: optional, filter on rule name. It is used as a string contains filter
   * - **statuses**:  optional, filter on status of findings
   * - **return**: [FindingRead]
   *     The output will contain a PaginationModel containing the list of FindingRead type objects,
   *     or an empty list if no scan was found
   */
  get_scan_findings_resc_v1_scans__scan_id__findings_get: {
    parameters: {
      query?: {
        skip?: number;
        limit?: number;
        rule?: string[];
        status?: components['schemas']['FindingStatus'][];
      };
      path: {
        scan_id: number;
      };
    };
    responses: {
      /** @description Retrieve findings associated with scan <scan_id> */
      200: {
        content: {
          'application/json': components['schemas']['PaginationModel_FindingRead_'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Create scan findings
   * @description Creates findings and their associated scan_findings for a given scan
   *
   * - **db_connection**: Session of the database connection
   * - **scan_id**:  Id of the scan for which findings need to be inserted
   * - **file_path**: file path
   * - **line_number**: Line number
   * - **column_start**: Column start
   * - **column_end**: Column end
   * - **commit_id**: commit hash
   * - **commit_message**: Commit message
   * - **commit_timestamp**: Commit timestamp
   * - **author**: Author name
   * - **email**: Email of the author
   * - **status**: Status of the finding, Valid values are NOT_ANALYZED, UNDER_REVIEW,
   *               CLARIFICATION_REQUIRED, FALSE_POSITIVE, TRUE_POSITIVE
   * - **comment**: Comment
   * - **event_sent_on**: event sent timestamp
   * - **rule_name**: rule name
   * - **repository_id**: repository id of the finding
   * - **return**: [FindingRead]
   *     The output will contain a PaginationModel containing the list of FindingRead type objects,
   *     or an empty list if no scan was found
   */
  create_scan_findings_resc_v1_scans__scan_id__findings_post: {
    parameters: {
      path: {
        scan_id: number;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FindingCreate'][];
      };
    };
    responses: {
      /** @description Create findings and their associated scan_findings for scan <scan_id> */
      201: {
        content: {
          'application/json': number;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get scan findings
   * @description Retrieve all finding objects paginated related to a scan_id
   *
   * - **db_connection**: Session of the database connection
   * - **scan_ids**: Optional, List of scan IDs for which findings to be retrieved
   * - **skip**: Integer amount of records to skip to support pagination
   * - **limit**: Integer amount of records to return, to support pagination
   * - **rule**: optional, filter on rule name. It is used as a string contains filter
   * - **statuses**:  optional, filter on status of findings
   * - **return**: [FindingRead]
   *     The output will contain a PaginationModel containing the list of FindingRead type objects,
   *     or an empty list if no scan was found
   */
  get_scans_findings_resc_v1_scans_findings__get: {
    parameters: {
      query?: {
        scan_id?: number[];
        skip?: number;
        limit?: number;
        rule?: string[];
        status?: components['schemas']['FindingStatus'][];
      };
    };
    responses: {
      /** @description Retrieve findings associated with scan <scan_id> */
      200: {
        content: {
          'application/json': components['schemas']['PaginationModel_FindingRead_'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get unique rules from scans
   * @description Retrieve all uniquely detected rules for given scans
   *
   * - **db_connection**: Session of the database connection
   * - **scan_ids**: scan ids for which to retrieve the unique rules
   * - **return**: List[str]
   *     The output will contain a list of strings of unique rules for given scan ids
   */
  get_distinct_rules_from_scans_resc_v1_scans_detected_rules__get: {
    parameters: {
      query?: {
        scan_id?: number[];
      };
    };
    responses: {
      /** @description Retrieve all the unique rules associated with specified scans */
      200: {
        content: {
          'application/json': string[];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get all VCS instances
   * @description Retrieve all VCS instance objects paginated
   *
   * - **db_connection**: Session of the database connection
   * - **skip**: Integer amount of records to skip to support pagination
   * - **limit**: Integer amount of records to return, to support pagination
   * - **vcs_provider_type**: Optional filter on the VCS provider type
   * - **vcs_instance_name**: Optional filter on VCS instance name
   * - **return**: [VCSInstanceRead]
   *     The output will contain a PaginationModel containing the list of VCSInstanceRead type objects,
   *     or an empty list if no VCS instance was found
   */
  get_all_vcs_instances_resc_v1_vcs_instances_get: {
    parameters: {
      query?: {
        skip?: number;
        limit?: number;
        vcs_provider_type?: components['schemas']['VCSProviders'];
        vcs_instance_name?: string;
      };
    };
    responses: {
      /** @description Retrieve all the VCS Instances */
      200: {
        content: {
          'application/json': components['schemas']['PaginationModel_VCSInstanceRead_'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Create a VCS instance
   * @description Create new VCS instance object
   *
   * - **db_connection**: Session of the database connection
   * - **vcs_instance**: VCSInstanceCreate type object of the VCS Instance to create
   * - **return**: VCSInstanceRead
   *     The output will contain a VCSInstanceRead type object if the creation was successful
   */
  create_vcs_instance_resc_v1_vcs_instances_post: {
    requestBody: {
      content: {
        'application/json': components['schemas']['VCSInstanceCreate'];
      };
    };
    responses: {
      /** @description Create new VCS instance */
      201: {
        content: {
          'application/json': components['schemas']['VCSInstanceRead'];
        };
      };
      /** @description Error creating new VCS instance */
      400: {
        content: {
          'application/json': components['schemas']['Model400'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Fetch a VCS instance by ID
   * @description Retrieve a VCS instance object based on the provided id
   *
   * - **db_connection**: Session of the database connection
   * - **vcs_instance_id**: ID of the VCS instance for which details need to be fetched
   * - **return**: VCSInstanceRead
   *     The output will contain a VCSInstanceRead type object from the requested ID
   */
  read_vcs_instance_resc_v1_vcs_instances__vcs_instance_id__get: {
    parameters: {
      path: {
        vcs_instance_id: number;
      };
    };
    responses: {
      /** @description Retrieve VCS Instance <vcs_instance_id> */
      200: {
        content: {
          'application/json': components['schemas']['VCSInstanceRead'];
        };
      };
      /** @description VCS Instance <vcs_instance_id> not found */
      404: {
        content: {
          'application/json': components['schemas']['Model404'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Update an existing VCS instance
   * @description Update a VCS instance
   *
   * - **db_connection**: Session of the database connection
   * - **vcs_instance_id**: ID of the VCS instance to update
   * - **provider_type**: VCS instance name that needs to be updated
   * - **hostname**: Host name of the VCS instance that needs to be updated
   * - **port**: Port number of the VCS instance that needs to be updated
   * - **scheme**: Scheme of the VCS instance that needs to be updated. Allowed values http or https
   * - **exceptions**: List of projects which needs to be updated to exception list, default empty list
   * - **scope**: List of projects which needs to be updated to scope
   * - **organization**: Name of organization to be updated, default is empty
   * - **return**: VCSInstanceRead
   *     The output will contain a VCSInstanceRead type object with the new properties
   */
  update_vcs_instance_resc_v1_vcs_instances__vcs_instance_id__put: {
    parameters: {
      path: {
        vcs_instance_id: number;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['VCSInstanceCreate'];
      };
    };
    responses: {
      /** @description Update VCS Instance <vcs_instance_id> */
      200: {
        content: {
          'application/json': components['schemas']['VCSInstanceRead'];
        };
      };
      /** @description VCS Instance <vcs_instance_id> not found */
      404: {
        content: {
          'application/json': components['schemas']['Model404'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Delete a VCS instance
   * @description Delete a VCS instance by ID
   *
   * - **db_connection**: Session of the database connection
   * - **vcs_instance_id**: ID of the VCS instance to delete
   * - **return**: The output will contain a success or error message based on the success of the deletion
   */
  delete_vcs_instance_resc_v1_vcs_instances__vcs_instance_id__delete: {
    parameters: {
      path: {
        vcs_instance_id: number;
      };
    };
    responses: {
      /** @description Delete VCS Instance <vcs_instance_id> */
      200: {
        content: {
          'application/json': unknown;
        };
      };
      /** @description VCS Instance <vcs_instance_id> not found */
      404: {
        content: {
          'application/json': components['schemas']['Model404'];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get count of audit status over time for given weeks per vcs provider
   * @description Retrieve count of audited findings over time for given weeks per vcs provider
   * - **db_connection**: Session of the database connection
   * - **weeks**: Nr of weeks for which to retrieve the audit status count
   * - **audit_status**: audit status for which to retrieve the counts, defaults to True positive
   * - **return**: [DateCountModel]
   *     The output will contain a list of DateCountModel type objects
   */
  get_finding_audit_count_over_time_resc_v1_metrics_audited_count_over_time_get: {
    parameters: {
      query?: {
        weeks?: number;
        audit_status?: components['schemas']['FindingStatus'];
      };
    };
    responses: {
      /** @description Retrieve count of audit status over time for given weeks per vcs provider */
      200: {
        content: {
          'application/json': components['schemas']['FindingCountOverTime'][];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get count of findings over time for given weeks per vcs provider
   * @description Retrieve count of findings over time for given weeks per vcs provider
   * - **db_connection**: Session of the database connection
   * - **weeks**: Nr of weeks for which to retrieve the audit status count
   * - **audit_status**: audit status for which to retrieve the counts, defaults to True positive
   * - **return**: [DateCountModel]
   *     The output will contain a list of DateCountModel type objects
   */
  get_finding_total_count_over_time_resc_v1_metrics_count_per_vcs_provider_by_week_get: {
    parameters: {
      query?: {
        weeks?: number;
      };
    };
    responses: {
      /** @description Retrieve count of findings over time for given weeks per vcs provider */
      200: {
        content: {
          'application/json': components['schemas']['FindingCountOverTime'][];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get count of UnTriaged findings over time for given weeks per vcs provider
   * @description Retrieve count of UnTriaged findings over time for given weeks per vcs provider
   * - **db_connection**: Session of the database connection
   * - **weeks**: Nr of weeks for which to retrieve the audit status count
   * - **audit_status**: audit status for which to retrieve the counts, defaults to True positive
   * - **return**: [DateCountModel]
   *     The output will contain a list of DateCountModel type objects
   */
  get_finding_un_triaged_count_over_time_resc_v1_metrics_un_triaged_count_over_time_get: {
    parameters: {
      query?: {
        weeks?: number;
      };
    };
    responses: {
      /** @description Retrieve count of UnTriaged findings over time for given weeks per vcs provider */
      200: {
        content: {
          'application/json': components['schemas']['FindingCountOverTime'][];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get count of Audits by Auditor over time for given weeks
   * @description Retrieve count of Audits by Auditor over time for given weeks
   * - **db_connection**: Session of the database connection
   * - **weeks**: Nr of weeks for which to retrieve the audit counts
   * - **return**: [AuditCountOverTime]
   *     The output will contain a list of AuditCountOverTime type objects
   */
  get_audit_count_by_auditor_over_time_resc_v1_metrics_audit_count_by_auditor_over_time_get: {
    parameters: {
      query?: {
        weeks?: number;
      };
    };
    responses: {
      /** @description Retrieve count of Audits by Auditor over time for given weeks */
      200: {
        content: {
          'application/json': components['schemas']['AuditCountOverTime'][];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /**
   * Get personal audit metrics
   * @description Retrieve personal audit metrics
   * - **db_connection**: Session of the database connection
   * - **return**: [DateCountModel]
   *     The output will contain a PersonalAuditMetrics type objects
   */
  get_personal_audit_metrics_resc_v1_metrics_personal_audits_get: {
    responses: {
      /** @description Get personal audit metrics */
      200: {
        content: {
          'application/json': components['schemas']['PersonalAuditMetrics'];
        };
      };
      /** @description Internal server error. Contact your system administrator */
      500: {
        content: never;
      };
      /** @description Unable to communicate with DataBase, Please contact your system administrator */
      503: {
        content: never;
      };
    };
  };
  /** View Docs */
  view_docs__get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          'application/json': unknown;
        };
      };
    };
  };
}
